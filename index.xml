<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>T[h]inking</title>
    <link>/</link>
    <description>Recent content on T[h]inking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Mar 2019 12:00:00 +0100</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to implement routing with n-ary tree</title>
      <link>/post/n-ary-routing/</link>
      <pubDate>Tue, 19 Mar 2019 12:00:00 +0100</pubDate>
      
      <guid>/post/n-ary-routing/</guid>
      <description>Routing mechanism is one of the main parts of a web service. Here I provide one approach to achieve this. This implementation is based on n-ary tree and tree search.
Many ways are available to handle routes, from regex to n-ary trees to parse registered route one by one.
Different ways N-ary Trees In this approach we can consider the root node as / and all children nodes as route parts are separated by /.</description>
    </item>
    
    <item>
      <title>The Multibuilder Pattern</title>
      <link>/post/multibuilder-pattern/</link>
      <pubDate>Tue, 08 Jan 2019 12:00:00 +0100</pubDate>
      
      <guid>/post/multibuilder-pattern/</guid>
      <description>In this post I would like to present a couple of solutions for builder pattern in python, and finally I show how I implemented a builder that I call multibuilder pattern.
Builder pattern comes in handy when we need to set a lot of fields of an object and we do not want to use many methods with multiple parameters.
All implementations are found in this repo: https://github.com/torokmark/builders_in_python
The Simple One Task: Let us implement a Person with the following fields like name, age, phone.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Tue, 01 Jan 2019 17:51:15 +0100</pubDate>
      
      <guid>/about/</guid>
      <description>Thoughts about coding and everything.
Mark, software engineer and avid learner!
Java enthusiast and Ruby monk.
Software tinker and DevOps thinker.</description>
    </item>
    
    <item>
      <title>Best practices to write an Entity in Spring/Hibernate</title>
      <link>/post/entity-best-practices/</link>
      <pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/entity-best-practices/</guid>
      <description>Every entity has to have a public default contstructor fetchType = FetchType.LAZY on @OneToOne, @OneToMany and @ManyToOne and other associations (EAGER is the default except @OneToMany) If an association is not mandatory:  optional = false on association annotations @Column and @JoinColumn should contain nullable = false  Entity should implement Persistable&amp;lt;IDTYPE&amp;gt; interface  Create own interface with default implementation:   public interface Identifiable extends Persistable&amp;lt;Long&amp;gt; { default isNew() { return getId() == null; } }  All ids should be boxed like Long, Integer, String, etc.</description>
    </item>
    
  </channel>
</rss>